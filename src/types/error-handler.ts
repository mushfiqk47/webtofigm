/**
 * Error Handling System
 * 
 * Implements hard-fail behavior with explicit diagnostics.
 * No silent degradation or approximations.
 */

/**
 * Error types for the conversion system
 */
export type ErrorCode =
    | 'SCHEMA_ERROR'
    | 'FONT_ERROR'
    | 'ASSET_ERROR'
    | 'CSS_ERROR'
    | 'VALIDATION_ERROR'
    | 'CAPTURE_ERROR'
    | 'IMPORT_ERROR';

/**
 * Structured error with context
 */
export interface ConversionError {
    code: ErrorCode;
    message: string;
    details?: string;
    element?: string;
    cssProperty?: string;
    recoverable: boolean;
}

/**
 * Error collection for batch reporting
 */
export class ErrorCollector {
    private errors: ConversionError[] = [];
    private warnings: ConversionError[] = [];

    /**
     * Add a critical error (causes hard-fail)
     */
    addError(error: Omit<ConversionError, 'recoverable'>): void {
        this.errors.push({ ...error, recoverable: false });
    }

    /**
     * Add a warning (logged but doesn't cause failure)
     */
    addWarning(error: Omit<ConversionError, 'recoverable'>): void {
        this.warnings.push({ ...error, recoverable: true });
    }

    /**
     * Check if any critical errors exist
     */
    hasErrors(): boolean {
        return this.errors.length > 0;
    }

    /**
     * Get all errors
     */
    getErrors(): ConversionError[] {
        return [...this.errors];
    }

    /**
     * Get all warnings
     */
    getWarnings(): ConversionError[] {
        return [...this.warnings];
    }

    /**
     * Format errors for user display
     */
    formatErrorsForDisplay(): string {
        if (this.errors.length === 0) {
            return '';
        }

        let output = '❌ Import Failed\n\n';
        output += `${this.errors.length} error(s) found:\n\n`;

        this.errors.forEach((error, index) => {
            output += `${index + 1}. [${error.code}] ${error.message}\n`;
            if (error.details) {
                output += `   Details: ${error.details}\n`;
            }
            if (error.element) {
                output += `   Element: ${error.element}\n`;
            }
            if (error.cssProperty) {
                output += `   CSS Property: ${error.cssProperty}\n`;
            }
            output += '\n';
        });

        return output;
    }

    /**
     * Format warnings for user display
     */
    formatWarningsForDisplay(): string {
        if (this.warnings.length === 0) {
            return '';
        }

        let output = `⚠️ ${this.warnings.length} warning(s):\n\n`;

        this.warnings.forEach((warning, index) => {
            output += `${index + 1}. ${warning.message}\n`;
        });

        return output;
    }

    /**
     * Clear all errors and warnings
     */
    clear(): void {
        this.errors = [];
        this.warnings = [];
    }
}

/**
 * Pre-defined error factories
 */
export const Errors = {
    missingFont(fontFamily: string, element?: string): ConversionError {
        return {
            code: 'FONT_ERROR',
            message: `Font not available: "${fontFamily}"`,
            details: 'Ensure this font is installed in Figma before importing.',
            element,
            recoverable: false
        };
    },

    missingAsset(assetUrl: string, element?: string): ConversionError {
        return {
            code: 'ASSET_ERROR',
            message: `Failed to load asset: "${assetUrl}"`,
            details: 'The image or asset could not be fetched or is corrupted.',
            element,
            recoverable: false
        };
    },

    unsupportedCss(property: string, value: string, element?: string): ConversionError {
        return {
            code: 'CSS_ERROR',
            message: `Unsupported CSS: ${property}: ${value}`,
            details: 'This CSS feature cannot be accurately represented in Figma.',
            element,
            cssProperty: property,
            recoverable: false
        };
    },

    schemaValidation(message: string): ConversionError {
        return {
            code: 'SCHEMA_ERROR',
            message: `Schema validation failed: ${message}`,
            recoverable: false
        };
    },

    invalidFile(message: string): ConversionError {
        return {
            code: 'VALIDATION_ERROR',
            message: `Invalid file: ${message}`,
            details: 'Only .htfig files generated by the HTML-to-Figma extension are accepted.',
            recoverable: false
        };
    },

    captureError(message: string, element?: string): ConversionError {
        return {
            code: 'CAPTURE_ERROR',
            message: `Capture failed: ${message}`,
            element,
            recoverable: false
        };
    }
};

/**
 * Global error collector instance
 */
export const globalErrorCollector = new ErrorCollector();
